---
phase: 03-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - railway.toml
autonomous: true
user_setup:
  - service: railway
    why: "Deployment platform"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio -> Get API key"
    dashboard_config:
      - task: "Create a new project and service in Railway"
        location: "https://railway.app/dashboard -> New Project"
      - task: "Connect GitHub repo or deploy via Railway CLI"
        location: "Railway Dashboard -> Service -> Settings -> Source"
      - task: "Add GEMINI_API_KEY environment variable"
        location: "Railway Dashboard -> Service -> Variables"

must_haves:
  truths:
    - "docker build produces a working image without errors"
    - "docker run starts the service and it responds to HTTP requests on the configured PORT"
    - "Health check at /health returns 200 with JSON status ok inside the container"
    - "The container works with a custom PORT environment variable (simulating Railway)"
    - "railway.toml configures Dockerfile builder and /health health check"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Docker build with UV package manager"
      contains: "python:3.12-slim"
    - path: ".dockerignore"
      provides: "Build context exclusions for dev/test artifacts"
      contains: ".venv/"
    - path: "railway.toml"
      provides: "Railway deployment configuration"
      contains: "healthcheckPath"
  key_links:
    - from: "Dockerfile CMD"
      to: "src.main:app"
      via: "uvicorn command"
      pattern: "uvicorn src.main:app"
    - from: "Dockerfile CMD"
      to: "PORT env var"
      via: "shell-form expansion"
      pattern: "PORT:-8000"
    - from: "railway.toml"
      to: "/health endpoint"
      via: "healthcheckPath config"
      pattern: "healthcheckPath"
---

<objective>
Create Docker containerization and Railway deployment configuration for the Claim API.

Purpose: Enable production deployment to Railway so curators can access the service via a public URL. This is the final phase -- the API and UI are complete, this adds the deployment wrapper.

Output: Dockerfile (multi-stage with UV), .dockerignore, railway.toml -- verified by building and running the image locally.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-deployment/03-RESEARCH.md
@pyproject.toml
@src/main.py
@src/config/settings.py
@src/routers/health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deployment configuration files</name>
  <files>Dockerfile, .dockerignore, railway.toml</files>
  <action>
Create three files at the project root:

**Dockerfile** -- Multi-stage build following the UV Docker guide pattern:
- Build stage: `FROM python:3.12-slim AS builder`, copy UV binary from `ghcr.io/astral-sh/uv:latest`
- Set `UV_COMPILE_BYTECODE=1 UV_LINK_MODE=copy` for pre-compiled bytecode and proper venv copying
- Dependencies layer: COPY `pyproject.toml`, `uv.lock`, `README.md` then `uv sync --locked --no-install-project --no-dev` with cache mount
- Application layer: COPY `src/` then `uv sync --locked --no-dev` with cache mount
- Runtime stage: `FROM python:3.12-slim`, copy only `.venv` and `src/` from builder
- Set `PATH="/app/.venv/bin:$PATH"`, `EXPOSE 8000`
- Shell-form CMD (NOT exec-form -- Railway needs shell expansion for $PORT): `CMD uvicorn src.main:app --host 0.0.0.0 --port ${PORT:-8000} --proxy-headers`
- Include `--proxy-headers` since Railway terminates TLS at edge and proxies to the container (low-risk best practice per research)

**IMPORTANT:** Use shell-form CMD, not exec-form. Exec-form `CMD ["uvicorn", ...]` cannot expand `$PORT`. This is the most common Railway deployment pitfall.

**.dockerignore** -- Exclude dev/build artifacts from Docker build context:
```
.venv/
.git/
.gitignore
.env
.env.example
__pycache__/
*.pyc
.mypy_cache/
.pytest_cache/
.ruff_cache/
*.egg-info/
dist/
build/
htmlcov/
.coverage
tests/
.planning/
.claude/
submodules/
```
Note: Do NOT exclude README.md -- it is needed by `uv sync` in the build stage because `pyproject.toml` references it via `readme = "README.md"`.

**railway.toml** -- Railway config-as-code:
```toml
[build]
builder = "DOCKERFILE"

[deploy]
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "ON_FAILURE"
restartPolicyMaxRetries = 3
```
  </action>
  <verify>All three files exist at project root: `ls Dockerfile .dockerignore railway.toml`</verify>
  <done>Dockerfile, .dockerignore, and railway.toml exist with correct content</done>
</task>

<task type="auto">
  <name>Task 2: Build and verify Docker image locally</name>
  <files></files>
  <action>
Build the Docker image and verify it works correctly:

1. Run `docker build -t claim-api .` from the project root. Must complete without errors.

2. Run the container without GEMINI_API_KEY to verify startup and health check:
   `docker run --rm -d -p 8000:8000 --name claim-api-test claim-api`
   Then test: `curl -s http://localhost:8000/health` -- must return `{"status":"ok"}`
   Also test the UI route: `curl -s -o /dev/null -w '%{http_code}' http://localhost:8000/` -- must return 200
   Stop: `docker stop claim-api-test`

3. Run with custom PORT to simulate Railway's PORT injection:
   `docker run --rm -d -p 3000:3000 -e PORT=3000 --name claim-api-port-test claim-api`
   Then test: `curl -s http://localhost:3000/health` -- must return `{"status":"ok"}`
   Stop: `docker stop claim-api-port-test`

4. Verify image size is reasonable (should be under 300MB for python:3.12-slim + deps):
   `docker images claim-api --format '{{.Size}}'`

If any step fails, diagnose and fix the Dockerfile before proceeding.
  </action>
  <verify>
All verification commands pass:
- `docker build -t claim-api .` succeeds
- Health check returns `{"status":"ok"}` on default port 8000
- UI route returns HTTP 200 on default port 8000
- Health check returns `{"status":"ok"}` on custom port 3000 (simulating Railway PORT injection)
- Image size is under 300MB
  </verify>
  <done>Docker image builds successfully, starts the service, responds to health checks on both default and custom ports, and serves the web UI</done>
</task>

</tasks>

<verification>
Phase 3 success criteria check:
1. `docker build` produces a working image -- verified by Task 2 build step
2. `docker run` starts service responding on configured PORT -- verified by Task 2 health checks on port 8000 and 3000
3. railway.toml exists with Dockerfile builder and /health health check -- verified by Task 1
4. Railway deployment (criterion 2 from roadmap) requires user to deploy to Railway -- covered by user_setup in frontmatter
</verification>

<success_criteria>
- Dockerfile builds a working multi-stage image with UV
- Container starts and responds to /health with {"status":"ok"}
- Container serves the web UI at /
- PORT environment variable is respected (shell-form CMD expansion works)
- railway.toml configures Dockerfile builder with /health health check
- .dockerignore excludes dev artifacts, keeps README.md for build stage
</success_criteria>

<output>
After completion, create `.planning/phases/03-deployment/03-01-SUMMARY.md`
</output>
