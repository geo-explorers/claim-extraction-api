---
phase: 02-web-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/templates/index.html
  - src/static/app.js
  - src/main.py
  - tests/test_routers/test_ui.py
autonomous: true

must_haves:
  truths:
    - "Opening GET / in a browser shows a page with a textarea and a Generate button"
    - "Clicking Generate calls POST /generate/claims, shows 'Thinking...' spinner with button disabled, then renders claims grouped by topic in a table"
    - "Export CSV button downloads a .csv file with claim_topic and claim columns, RFC 4180 escaping, and UTF-8 BOM"
    - "API errors display as a human-readable message below the Generate button"
    - "Re-generating when results exist shows a native confirm() dialog before replacing"
  artifacts:
    - path: "src/templates/index.html"
      provides: "Jinja2 template with Tailwind v4 CDN, textarea, Generate button, loading spinner, error area, results table, Export CSV button"
      contains: "Claim Extractor"
    - path: "src/static/app.js"
      provides: "Fetch handler, DOM rendering, CSV export, groupByTopic, escapeHTML, escapeCSV, confirm dialog"
      contains: "handleGenerate"
    - path: "src/main.py"
      provides: "StaticFiles mount at /static, Jinja2Templates setup, GET / route"
      contains: "StaticFiles"
    - path: "tests/test_routers/test_ui.py"
      provides: "Tests for GET / returning HTML with expected elements"
      contains: "test_index"
  key_links:
    - from: "src/templates/index.html"
      to: "src/static/app.js"
      via: "script tag using url_for('static', path='app.js')"
      pattern: "url_for.*static.*app\\.js"
    - from: "src/static/app.js"
      to: "POST /generate/claims"
      via: "fetch() call in handleGenerate"
      pattern: "fetch.*generate/claims"
    - from: "src/main.py"
      to: "src/templates/index.html"
      via: "Jinja2Templates.TemplateResponse"
      pattern: "TemplateResponse.*index\\.html"
---

<objective>
Add the web UI for curators to paste source text, generate claims, and export results as CSV.

Purpose: Non-technical curators need a simple web page to interact with the Phase 1 extraction API without using curl or Postman.
Output: A working web interface at GET / with textarea input, topic-grouped claims table, CSV export, loading states, and error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-web-ui/02-RESEARCH.md
@.planning/phases/02-web-ui/02-CONTEXT.md
@src/main.py
@src/schemas/responses.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jinja2 template and JavaScript frontend</name>
  <files>src/templates/index.html, src/static/app.js</files>
  <action>
Create two new directories and files:

**src/templates/index.html** -- Jinja2 template:
- DOCTYPE html with lang="en", UTF-8 charset, responsive viewport meta
- Title: "Claim Extractor"
- Tailwind CSS v4 via CDN: `<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>`
- Centered layout with max-w-[960px] mx-auto, light mode only
- Simple title bar: `<h1>` with "Claim Extractor", no navigation links
- Textarea: id="source-text", full width, 10 rows, monospace font, placeholder "Paste your source text here..."
- Generate button: id="generate-btn", blue bg, disabled styling with opacity-50 and cursor-not-allowed
- Loading indicator: id="loading", hidden by default, CSS border spinner (w-4 h-4 border-2 border-gray-400 border-t-transparent rounded-full animate-spin) with "Thinking..." label (per user decision -- specifically "Thinking..." not "Loading..." or "Generating...")
- Error area: id="error", hidden by default, red-tinted bg-red-50 border-red-200 text-red-700 rounded
- Results section: id="results", hidden by default, contains:
  - Total count: id="total-count" (e.g. "42 claims extracted")
  - Export CSV button: id="export-btn", green bg, placed next to total count above table
  - Table with thead (Topic, Claim columns) and empty tbody id="claims-body"
- Script tag at bottom: `<script src="{{ url_for('static', path='app.js') }}"></script>`

**src/static/app.js** -- Vanilla JavaScript:
- State: `let currentClaims = []`
- DOM element references by getElementById for all interactive elements
- Event listeners on generate-btn (click -> handleGenerate) and export-btn (click -> handleExport)
- `handleGenerate()`:
  - Get trimmed text from textarea, return early if empty
  - If currentClaims.length > 0, show native `confirm("This will replace the current results. Continue?")`, return if cancelled
  - Call `setLoading(true)`, `hideError()`
  - fetch POST /generate/claims with JSON body {source_text}, Content-Type application/json
  - On !response.ok: try parse response.json() for .detail, fallback to response.statusText, fallback to generic message. Throw Error with message.
  - On success: parse response.json(), store data.claims in currentClaims, call renderClaims()
  - catch: call showError(err.message), hide results
  - finally: setLoading(false)
- `renderClaims(claims)`:
  - Call groupByTopic(claims) to get {topic: [claim_strings]}
  - Set totalCount.textContent to `${claims.length} claims extracted`
  - Clear claimsBody.innerHTML
  - For each topic group: insert a bold header row spanning 2 columns with "${topic} (${count} claims)", then individual claim rows with topic in col 1 (gray text) and claim in col 2
  - Use escapeHTML() for all user-generated content
  - Show results section
- `groupByTopic(claims)`: group flat claims array into {claim_topic: [claim_text]} preserving API order
- `escapeHTML(str)`: create div, set textContent, return innerHTML
- `setLoading(on)`: toggle loading visibility, toggle generateBtn.disabled
- `showError(message)` / `hideError()`: set error text, show/hide error div
- `handleExport()`:
  - Return early if no currentClaims
  - Build CSV: header "claim_topic,claim", rows with escapeCSV on both fields
  - Prepend UTF-8 BOM (\uFEFF) for Excel compatibility
  - Create Blob with type "text/csv;charset=utf-8;"
  - Create object URL, trigger download via hidden anchor with filename "claims.csv"
  - Revoke object URL after click
- `escapeCSV(value)`: RFC 4180 compliant -- if value contains comma, double-quote, newline, or carriage return, wrap in double quotes and double any internal double quotes

Reference the code examples in 02-RESEARCH.md for exact implementations. The research has verified, working code for all functions.
  </action>
  <verify>
    - `ls src/templates/index.html src/static/app.js` -- both files exist
    - index.html contains: Tailwind v4 CDN script tag, id="source-text", id="generate-btn", id="loading", "Thinking...", id="error", id="results", id="total-count", id="export-btn", id="claims-body", url_for('static', path='app.js')
    - app.js contains: handleGenerate, handleExport, renderClaims, groupByTopic, escapeHTML, escapeCSV, setLoading, showError, hideError, currentClaims, confirm(, \uFEFF, /generate/claims
  </verify>
  <done>
    - index.html is a valid Jinja2 template with Tailwind v4 CDN, all required UI elements with correct IDs, and app.js loaded via url_for
    - app.js has complete client-side logic: API fetch, topic-grouped table rendering, CSV export with BOM and RFC 4180 escaping, loading/error states, confirm dialog for re-generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire templates and static files into FastAPI, add tests</name>
  <files>src/main.py, tests/test_routers/test_ui.py</files>
  <action>
**src/main.py** -- Add template and static file serving:
- Add imports: `from pathlib import Path`, `from fastapi.staticfiles import StaticFiles`, `from fastapi.templating import Jinja2Templates`, `from fastapi.responses import HTMLResponse`
- Define `BASE_DIR = Path(__file__).resolve().parent` at module level (after imports, before app)
- After `app = FastAPI(...)` and before middleware: mount static files with `app.mount("/static", StaticFiles(directory=BASE_DIR / "static"), name="static")`
- Initialize templates: `templates = Jinja2Templates(directory=BASE_DIR / "templates")`
- Add GET / route BEFORE the router includes:
  ```python
  @app.get("/", response_class=HTMLResponse)
  async def index(request: Request) -> HTMLResponse:
      return templates.TemplateResponse(request=request, name="index.html")
  ```
- Use named parameters for TemplateResponse (modern FastAPI 0.108.0+ style)
- Mount order: StaticFiles first, then GET / route, then middleware, then include_router calls. This ensures /static is resolved before routers.
- Keep the existing `from fastapi import Request` import (already present)
- Ensure ruff check and mypy --strict pass. The TemplateResponse return type may need `type: ignore[return-value]` if mypy complains about HTMLResponse vs TemplateResponse -- TemplateResponse IS an HTMLResponse subclass so it's correct.

**tests/test_routers/test_ui.py** -- Test the UI route:
- Import TestClient, app from src.main
- Follow existing test patterns from tests/test_routers/test_health.py (use similar structure)
- Test: `test_index_returns_html` -- GET / returns 200 with content-type text/html and body containing "Claim Extractor"
- Test: `test_index_contains_textarea` -- GET / response body contains id="source-text"
- Test: `test_index_contains_generate_button` -- GET / response body contains id="generate-btn"
- Test: `test_index_loads_app_js` -- GET / response body contains /static/app.js (the script tag)
- Test: `test_static_app_js_served` -- GET /static/app.js returns 200 with content-type containing "javascript"
- Use `from __future__ import annotations` at top
- Follow ruff conventions established in Phase 1 (TYPE_CHECKING blocks if needed)
  </action>
  <verify>
    - `uv run ruff check src/main.py tests/test_routers/test_ui.py` -- no errors
    - `uv run mypy --strict src/main.py` -- no errors (or minimal type: ignore for TemplateResponse)
    - `uv run pytest tests/test_routers/test_ui.py -v` -- all tests pass
    - `uv run pytest` -- full suite passes (existing + new tests)
    - `curl -s http://localhost:8000/ | head -5` shows HTML with "Claim Extractor" (manual verify if server running)
  </verify>
  <done>
    - GET / returns the Jinja2 template as HTML with Claim Extractor page
    - GET /static/app.js returns the JavaScript file
    - All existing tests continue to pass (no regressions)
    - ruff check and mypy --strict pass on all modified files
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check src/ tests/` -- zero errors
2. `uv run mypy --strict src/` -- zero errors
3. `uv run pytest -v` -- all tests pass (existing + new UI tests)
4. Files exist: src/templates/index.html, src/static/app.js
5. src/main.py mounts /static and serves GET / with TemplateResponse
</verification>

<success_criteria>
- GET / returns an HTML page containing a textarea, Generate button, and all required UI elements
- GET /static/app.js returns the JavaScript frontend code
- The JavaScript handles fetch to /generate/claims, topic-grouped rendering, CSV export with BOM, loading states, error display, and confirm dialog
- All quality gates pass: ruff check, mypy --strict, pytest
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/02-web-ui/02-01-SUMMARY.md`
</output>
