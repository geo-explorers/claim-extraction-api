---
phase: 01-core-extraction-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - .python-version
  - .env.example
  - src/__init__.py
  - src/main.py
  - src/config/__init__.py
  - src/config/settings.py
  - src/schemas/__init__.py
  - src/schemas/requests.py
  - src/schemas/responses.py
  - src/schemas/llm.py
  - src/exceptions.py
  - src/routers/__init__.py
  - src/routers/health.py
autonomous: true

must_haves:
  truths:
    - "GET /health returns {status: ok} without any Gemini dependency"
    - "App starts successfully when GEMINI_API_KEY is set"
    - "App fails fast at startup when GEMINI_API_KEY is missing"
    - "ruff check and mypy --strict pass on all source files"
  artifacts:
    - path: "pyproject.toml"
      provides: "UV project config with ruff, mypy, pytest settings"
      contains: "strict = true"
    - path: "src/config/settings.py"
      provides: "Pydantic BaseSettings loading env vars"
      contains: "gemini_api_key"
    - path: "src/schemas/requests.py"
      provides: "ClaimGenerationRequest with min/max length validation"
      contains: "min_length"
    - path: "src/schemas/responses.py"
      provides: "ClaimGenerationResponse and ClaimResponse models"
      contains: "ClaimGenerationResponse"
    - path: "src/schemas/llm.py"
      provides: "TopicResult and ClaimWithTopicResult Gemini response schemas"
      contains: "TopicResult"
    - path: "src/exceptions.py"
      provides: "Typed exception hierarchy mapping to HTTP status codes"
      exports: ["ExtractionError", "LLMProviderError", "SafetyFilterError", "InputValidationError"]
    - path: "src/main.py"
      provides: "FastAPI app with lifespan, CORS, exception handlers, health router"
      contains: "FastAPI"
    - path: "src/routers/health.py"
      provides: "GET /health endpoint"
      contains: "/health"
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "GEMINI_API_KEY"
  key_links:
    - from: "src/main.py"
      to: "src/config/settings.py"
      via: "imports settings for lifespan logging"
      pattern: "from src\\.config\\.settings import"
    - from: "src/main.py"
      to: "src/routers/health.py"
      via: "includes health router"
      pattern: "app\\.include_router"
---

<objective>
Initialize the UV project, install all dependencies, configure tooling (ruff, mypy, pytest), and build the foundational layer: settings, all Pydantic schemas, typed exceptions, health endpoint, and the FastAPI app shell.

Purpose: Every subsequent plan depends on this foundation -- schemas define the data contracts, settings provide configuration, exceptions define error handling, and the app shell is the integration point.
Output: A running FastAPI app with `/health` endpoint, all data models defined, all tooling passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-extraction-api/01-RESEARCH.md
@submodules/extraction-api/src/config/settings.py
@submodules/extraction-api/src/api/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize UV project with all dependencies and tooling config</name>
  <files>
    pyproject.toml
    .python-version
    .env.example
  </files>
  <action>
Initialize the UV project and install all dependencies:

```bash
uv init --name claim-api --python ">=3.12"
uv add "fastapi[standard]>=0.121.0" "google-genai>=1.50.0" "pydantic>=2.10.0" "pydantic-settings>=2.10.0" "python-dotenv>=1.0.0" "tenacity>=9.0.0"
uv add --dev "ruff>=0.9.0" "mypy>=1.14.0" "pytest>=8.0.0" "pytest-asyncio>=0.24.0,<1.0.0" "pytest-cov>=6.0.0"
```

Then configure tooling in `pyproject.toml` (add these sections to whatever UV generates):

```toml
[tool.ruff]
target-version = "py312"
line-length = 99

[tool.ruff.lint]
select = ["E", "F", "I", "N", "UP", "B", "A", "SIM", "TCH"]

[tool.mypy]
strict = true
plugins = ["pydantic.mypy"]

[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
```

Create `.env.example`:
```
GEMINI_API_KEY=your-gemini-api-key-here
GEMINI_MODEL=gemini-2.5-flash
GEMINI_TEMPERATURE=0.2
PORT=8000
LOG_LEVEL=INFO
```

Remove the `hello.py` or `main.py` file that `uv init` auto-generates at the project root (we use `src/main.py` instead).
  </action>
  <verify>
Run `uv sync` to confirm lockfile resolves. Run `uv run python -c "import fastapi; import google.genai; import tenacity; print('OK')"` to confirm imports work.
  </verify>
  <done>pyproject.toml exists with all dependencies and tool configs. uv.lock exists. .env.example documents all env vars. All imports resolve.</done>
</task>

<task type="auto">
  <name>Task 2: Create settings, schemas, exceptions, health endpoint, and FastAPI app</name>
  <files>
    src/__init__.py
    src/config/__init__.py
    src/config/settings.py
    src/schemas/__init__.py
    src/schemas/requests.py
    src/schemas/responses.py
    src/schemas/llm.py
    src/exceptions.py
    src/routers/__init__.py
    src/routers/health.py
    src/main.py
  </files>
  <action>
Create the full source tree. All files must pass `ruff check` and `mypy --strict`.

**src/config/settings.py** -- Pydantic BaseSettings:
- `gemini_api_key: str` (required, no default -- fails fast if missing)
- `gemini_model: str = "gemini-2.5-flash"`
- `gemini_temperature: float = 0.2`
- `port: int = 8000`
- `log_level: str = "INFO"`
- Use `SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False, extra="ignore")`
- Do NOT instantiate a module-level `settings` singleton yet -- it will be created via FastAPI dependency injection in Plan 03. Just export the `Settings` class.

**src/schemas/llm.py** -- Gemini structured output schemas (these are what Gemini returns, NOT the API response):
- `TopicResult(BaseModel)` with `topics: list[str]` and Field description: "List of concise, descriptive topic labels (3-10 words) extracted from source text in order of appearance."
- `ClaimWithTopicBaseResult(BaseModel)` with `topic: str` (Field desc: "Topic label from the provided list") and `claims: list[str]` (Field desc: "List of factual, self-contained, atomic claims (5-32 words each) under this topic.")
- `ClaimWithTopicResult(BaseModel)` with `claim_topics: list[ClaimWithTopicBaseResult]` (Field desc: "Claims organized by topic.")
- Note: use `claims` (plural) not `claim` for the list field in ClaimWithTopicBaseResult -- clearer for the LLM.

**src/schemas/requests.py** -- API request model:
- `ClaimGenerationRequest(BaseModel)` with `source_text: str = Field(..., min_length=50, max_length=50000, description="Source text to extract claims from (50-50,000 characters)")`

**src/schemas/responses.py** -- API response models:
- `ClaimResponse(BaseModel)` with `claim_topic: str` and `claim: str`
- `ClaimGenerationResponse(BaseModel)` with `claims: list[ClaimResponse]`
- `ErrorResponse(BaseModel)` with `detail: str`

**src/exceptions.py** -- Typed exception hierarchy:
- `ExtractionError(HTTPException)` -- base, status 502 BAD_GATEWAY
- `LLMProviderError(ExtractionError)` -- Gemini call failed after retries, status 502
- `SafetyFilterError(ExtractionError)` -- content blocked by safety filters, status 502
- `EmptyExtractionError(ExtractionError)` -- Gemini returned no topics/claims, status 502
- `InputValidationError(HTTPException)` -- invalid source text, status 422
- Follow the pattern from research: each exception has a default detail message, all extend HTTPException so FastAPI handles them automatically.

**src/routers/health.py** -- Health endpoint:
- `router = APIRouter(tags=["health"])`
- `GET /health` returns `{"status": "ok"}` -- no Gemini dependency, no settings dependency.
- Return type annotation: `dict[str, str]`

**src/main.py** -- FastAPI app:
- `asynccontextmanager` lifespan that logs startup/shutdown with model name
- During lifespan startup: instantiate `Settings()` (validates env vars, fails fast if GEMINI_API_KEY missing), create `genai.Client(api_key=settings.gemini_api_key)`, store both on `app.state`
- CORS middleware: allow all origins (for Phase 2 web UI)
- Global exception handler for unhandled `Exception` -- returns 500 with `{"detail": "An unexpected error occurred"}`
- Include health router
- Do NOT include generate router yet (created in Plan 03)

All `__init__.py` files should be empty.

Important: For mypy strict compliance, ensure all function signatures have return type annotations, all variables that could be `None` are typed accordingly, and no `Any` types are used.
  </action>
  <verify>
Run all three checks:
1. `uv run ruff check src/` -- must pass with 0 errors
2. `uv run mypy --strict src/` -- must pass with 0 errors
3. `GEMINI_API_KEY=test-key uv run uvicorn src.main:app --host 0.0.0.0 --port 8000 &` then `curl http://localhost:8000/health` must return `{"status":"ok"}`. Kill the server after.
4. Verify missing key fails: `unset GEMINI_API_KEY && uv run python -c "from src.config.settings import Settings; Settings()"` should raise a validation error.
  </verify>
  <done>FastAPI app starts, /health returns {"status":"ok"}, all schemas importable, exceptions defined, ruff and mypy pass clean. App fails fast when GEMINI_API_KEY is missing.</done>
</task>

</tasks>

<verification>
1. `uv run ruff check src/` passes with 0 errors
2. `uv run mypy --strict src/` passes with 0 errors
3. `curl localhost:8000/health` returns `{"status":"ok"}`
4. All schema classes importable: `uv run python -c "from src.schemas.llm import TopicResult, ClaimWithTopicResult; from src.schemas.requests import ClaimGenerationRequest; from src.schemas.responses import ClaimGenerationResponse; print('OK')"`
5. Exception hierarchy works: `uv run python -c "from src.exceptions import LLMProviderError; e = LLMProviderError(); assert e.status_code == 502; print('OK')"`
</verification>

<success_criteria>
- UV project initialized with all dependencies installed and locked
- pyproject.toml has ruff, mypy, pytest configuration
- .env.example documents all environment variables
- Settings class validates env vars with fail-fast on missing GEMINI_API_KEY
- All Pydantic schemas defined (request, response, LLM)
- Typed exception hierarchy with HTTP status code mapping
- FastAPI app runs with /health endpoint returning {"status":"ok"}
- ruff check and mypy --strict pass on all source files
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-extraction-api/01-01-SUMMARY.md`
</output>
