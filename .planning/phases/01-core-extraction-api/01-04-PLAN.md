---
phase: 01-core-extraction-api
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/settings.py
  - src/main.py
  - src/dependencies.py
  - tests/test_routers/test_health.py
  - tests/conftest.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "GET /health returns {status: ok} when GEMINI_API_KEY is not set"
    - "POST /generate/claims still works when GEMINI_API_KEY is set"
    - "POST /generate/claims returns 503 with clear error when GEMINI_API_KEY is not set"
    - "All 21 existing tests plus new tests pass"
    - "ruff check, mypy --strict pass cleanly"
  artifacts:
    - path: "src/config/settings.py"
      provides: "Settings with optional gemini_api_key"
      contains: "gemini_api_key: str | None"
    - path: "src/main.py"
      provides: "Lifespan that defers Gemini init when key is missing"
      contains: "if settings.gemini_api_key"
    - path: "src/dependencies.py"
      provides: "Dependency that raises 503 when Gemini not configured"
      contains: "HTTP_503_SERVICE_UNAVAILABLE"
    - path: "tests/test_routers/test_health.py"
      provides: "Test proving health works without GEMINI_API_KEY"
  key_links:
    - from: "src/config/settings.py"
      to: "src/main.py"
      via: "Settings().gemini_api_key checked before genai.Client creation"
      pattern: "if settings\\.gemini_api_key"
    - from: "src/dependencies.py"
      to: "src/main.py"
      via: "app.state.claim_generation_service may be None"
      pattern: "getattr.*claim_generation_service.*None"
---

<objective>
Fix blocker: app crashes on startup without GEMINI_API_KEY, making health endpoint unreachable.

Purpose: The health endpoint must respond without requiring Gemini configuration. This is critical for deployment health checks (Railway) and basic service availability verification.

Output: App starts successfully without GEMINI_API_KEY. Health endpoint always works. Generate endpoint returns clear 503 when Gemini is not configured.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-extraction-api/01-UAT.md
@src/config/settings.py
@src/main.py
@src/dependencies.py
@src/routers/health.py
@src/routers/generate.py
@src/exceptions.py
@tests/conftest.py
@tests/test_routers/test_health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make gemini_api_key optional and defer Gemini initialization</name>
  <files>src/config/settings.py, src/main.py, src/dependencies.py</files>
  <action>
Three files need surgical changes:

**src/config/settings.py:**
- Change `gemini_api_key: str` to `gemini_api_key: str | None = Field(default=None, description="Google Gemini API key (optional at startup, required for /generate endpoints)")`.
- This allows `Settings()` to succeed without `GEMINI_API_KEY` in the environment.

**src/main.py:**
- In the `lifespan` function, wrap the Gemini client and extractor creation in a conditional: `if settings.gemini_api_key:`.
- When the key IS present: create `genai.Client`, `TopicExtractor`, `ClaimExtractor`, `ClaimGenerationService` and store on `app.state.claim_generation_service` exactly as today.
- When the key IS NOT present: log a warning (`logger.warning("GEMINI_API_KEY not set -- /generate endpoints will return 503")`) and set `app.state.claim_generation_service = None`.
- Always store `app.state.settings = settings` regardless of key presence.
- Keep the `genai` import. Keep `app.state.gemini_client` assignment inside the conditional block (only set when key is present).

**src/dependencies.py:**
- Modify `get_claim_generation_service` to handle `None` on app.state.
- Use `getattr(request.app.state, "claim_generation_service", None)` to safely retrieve the service.
- If the service is `None`, raise `HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Gemini API key not configured. Set GEMINI_API_KEY environment variable.")`.
- Add the necessary imports: `from fastapi import HTTPException, Request, status`.

Do NOT change src/routers/health.py -- it is already correct.
Do NOT change src/routers/generate.py -- it already uses dependency injection.
Do NOT change src/exceptions.py.
  </action>
  <verify>
Run `uv run mypy --strict src/` -- must pass with zero errors.
Run `uv run ruff check src/` -- must pass.
Run `uv run python -c "from src.config.settings import Settings; s = Settings(); print(s.gemini_api_key)"` (without GEMINI_API_KEY set) -- must print `None`, not crash.
  </verify>
  <done>
Settings() succeeds without GEMINI_API_KEY. Lifespan conditionally creates Gemini resources. Dependency raises 503 when service is None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests to cover health-without-key and generate-without-key scenarios</name>
  <files>tests/test_routers/test_health.py, tests/conftest.py</files>
  <action>
**tests/test_routers/test_health.py:**
- Add a new test `test_health_works_without_gemini_key` that:
  1. Temporarily removes `GEMINI_API_KEY` from `os.environ` if present (use `monkeypatch.delenv("GEMINI_API_KEY", raising=False)`).
  2. Creates a `TestClient(app)` (this triggers lifespan).
  3. Asserts `GET /health` returns 200 with `{"status": "ok"}`.
  4. This is the KEY test that proves the gap is closed.
- Refactor the existing `_health_client` generator into a proper pytest fixture if needed, or add the new test using `monkeypatch` directly.
- Remove the `os.environ.setdefault("GEMINI_API_KEY", "test-key")` from the existing `_health_client` helper -- the health tests should work without it. If the existing tests need a client, create a simple fixture that uses `TestClient(app)` directly without setting GEMINI_API_KEY.

**tests/test_routers/test_health.py -- add test for 503 on generate without key:**
- Add a test `test_generate_returns_503_without_gemini_key` (can be in test_health.py or a new section) that:
  1. Removes GEMINI_API_KEY from env via monkeypatch.
  2. Creates `TestClient(app)`.
  3. POSTs to `/generate/claims` with valid JSON body.
  4. Asserts 503 status and "not configured" in the error detail.

**tests/conftest.py:**
- The `app_client` fixture already sets `os.environ.setdefault("GEMINI_API_KEY", "test-key")` which is correct -- it ensures existing generate tests pass. No change needed here.
- Verify all 21 existing tests still pass without modification.

Run the full test suite: `uv run pytest -v`. All existing tests must pass plus the new tests.
Run `uv run ruff check tests/` and `uv run mypy --strict tests/` -- must pass.
  </action>
  <verify>
Run `uv run pytest -v` -- all tests pass (21 existing + 2-3 new).
Run `uv run ruff check src/ tests/` -- passes.
Run `uv run mypy --strict src/` -- passes.
Manually verify: `unset GEMINI_API_KEY && uv run uvicorn src.main:app --port 8000` then `curl http://localhost:8000/health` returns `{"status":"ok"}`.
  </verify>
  <done>
New tests prove: (1) health works without GEMINI_API_KEY, (2) generate returns 503 without GEMINI_API_KEY. All 21+ existing tests still pass. All quality gates (ruff, mypy, pytest) pass cleanly.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check src/ tests/` -- zero errors
2. `uv run mypy --strict src/` -- zero errors
3. `uv run pytest -v` -- all tests pass (existing 21 + new gap-closure tests)
4. Manual: `unset GEMINI_API_KEY && uv run uvicorn src.main:app --port 8000` starts without crash
5. Manual: `curl http://localhost:8000/health` returns `{"status": "ok"}` (HTTP 200)
6. Manual: `curl -X POST http://localhost:8000/generate/claims -H "Content-Type: application/json" -d '{"source_text": "test text"}'` returns 503 with "not configured" message
</verification>

<success_criteria>
- App starts successfully without GEMINI_API_KEY environment variable
- GET /health returns {"status": "ok"} (HTTP 200) regardless of GEMINI_API_KEY
- POST /generate/claims returns HTTP 503 with clear error when GEMINI_API_KEY is not set
- POST /generate/claims works normally when GEMINI_API_KEY is set (existing behavior preserved)
- All quality gates pass: ruff check, mypy --strict, pytest
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-extraction-api/01-04-SUMMARY.md`
</output>
